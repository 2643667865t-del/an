<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé€Ÿèµ›è½¦æ™ºèƒ½è§„å¾‹é¢„æµ‹ï¼ˆå†·çƒ­è½¬æ¢ç¨³å®šç‰ˆ V5.6 ç²¾ç®€å›æµ‹100æœŸï¼‰</title>
    
    <style>
        /* ========================================= */
        /* I. ä¸»é¡µé¢é€šç”¨æ ·å¼ (ä¿æŒç¨³å®š) */
        /* ========================================= */
        body { font-family: 'Arial', sans-serif; margin: 0; padding: 0 10px; background-color: #f0f2f5; font-size: 12px; overflow-x: hidden; }
        .container { max-width: 768px; width: 100%; margin: 10px auto; background-color: #fff; padding: 10px; border-radius: 4px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); }
        h1, h2 { color: #333; text-align: center; margin-bottom: 10px; font-size: 1.2em; }
        #status-message { padding: 5px; color: #d9534f; font-weight: bold; margin-bottom: 10px; text-align: center; font-size: 1em; }

        /* é¡¶éƒ¨ä¿¡æ¯å¡ */
        #top-info-card { background-color: #f5f5f5; padding: 15px 10px; margin-bottom: 15px; border-radius: 4px; border: 1px solid #ddd; }
        #latest-issue-title { font-size: 1.1em; color: #007bff; margin-bottom: 8px; font-weight: bold; }
        #latest-numbers-display { display: flex; justify-content: space-evenly; margin-bottom: 15px; }
        #countdown-section { text-align: center; font-size: 1.2em; font-weight: bold; color: #d9534f; padding-top: 5px; border-top: 1px dashed #ccc; }
        
        /* é¡¶éƒ¨å¤§çƒæ ·å¼ */
        .top-ball { display: inline-flex; width: 28px; height: 28px; line-height: 28px; border-radius: 0; color: white; font-size: 14px; font-weight: bold; flex-shrink: 0; align-items: center; justify-content: center; margin: 0 1px; box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2); }

        /* å†å²è¡¨æ ¼æ ·å¼ */
        #data-table { width: 100%; border-collapse: collapse; font-size: 11px; table-layout: fixed; margin-top: 10px; }
        #data-table th, #data-table td { border: 1px solid #ddd; padding: 3px 1px; text-align: center; vertical-align: middle; }
        #data-table th { background-color: #007bff; color: white; font-weight: bold; }
        #data-table tbody tr:nth-child(odd) { background-color: #f9f9f9; }
        .balls-container { display: flex; justify-content: space-evenly; align-items: center; flex-wrap: nowrap; padding: 0; }
        
        /* å†å²è¡¨æ ¼ä¸­çš„å°çƒæ ·å¼ */
        .ball { display: inline-flex; width: 20px; height: 20px; line-height: 20px; border-radius: 0; color: white; font-size: 11px; font-weight: bold; flex-shrink: 0; align-items: center; justify-content: center; margin: 0; }
        
        /* æé€Ÿèµ›è½¦å·ç é¢œè‰²å®šä¹‰ (1-10) - ä¿æŒä¸å˜ */
        .color-1 { background-color: #f08346; } .color-2 { background-color: #5587f7; } 
        .color-3 { background-color: #4dc54b; } .color-4 { background-color: #f24e6a; } 
        .color-5 { background-color: #9258df; } .color-6 { background-color: #26c0c4; } 
        .color-7 { background-color: #909090; } .color-8 { background-color: #efb932; } 
        .color-9 { background-color: #c0879f; } .color-10 { background-color: #208759; } 

        /* é¢„æµ‹æŒ‰é’® - ä¸»é¡µå”¯ä¸€çš„åŠŸèƒ½æŒ‰é’® */
        .view-switch-button { background-color: #ffc107; color: #333; border: none; padding: 10px 15px; border-radius: 4px; width: 100%; margin-bottom: 15px; font-size: 1.1em; font-weight: bold; cursor: pointer; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); }


        /* ========================================= */
        /* II. é¢„æµ‹è§†å›¾ä¸“å±æ ·å¼ */
        /* ========================================= */
        
        #prediction-home-view, #model-detail-view { background-color: #fff; padding: 10px; }

        /* è¿”å›æŒ‰é’® */
        .back-button { background-color: #6c757d; color: white; border: none; padding: 8px 15px; border-radius: 4px; margin-bottom: 15px; cursor: pointer; }
        
        /* æ™ºèƒ½ç­›é€‰ç»“æœå¡ç‰‡ (é«˜äº®æ˜¾ç¤º) */
        #smart-prediction-card {
            background-color: #e6f7ff; 
            border: 2px solid #007bff;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        
        /* é¢„æµ‹å·ç æ–¹å— (ç”¨äºé¢„æµ‹åŒ…å›´) */
        .predict-ball {
            display: inline-flex;
            width: 28px;
            height: 28px;
            line-height: 28px;
            border-radius: 50%; 
            background-color: #dc3545; 
            color: white;
            font-size: 14px;
            font-weight: bold;
            align-items: center;
            justify-content: center;
            margin: 0 2px;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.2);
        }

        /* è¯¦æƒ…åˆ—è¡¨ */
        #lane-buttons-container { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .lane-button {
            padding: 10px;
            background-color: #f8f9fa; 
            color: #333; 
            border: 1px solid #ddd; 
            border-radius: 4px;
            font-size: 0.9em;
            text-align: left;
            cursor: pointer;
        }
        .result-win { color: green; font-weight: bold; } 
        .result-loss { color: red; font-weight: bold; } 

        /* å›æµ‹è¡¨æ ¼ */
        #backtest-table { width: 100%; border-collapse: collapse; font-size: 0.8em; margin-top: 15px; }
        #backtest-table th, #backtest-table td { border: 1px solid #ddd; padding: 5px; text-align: center; }
        #backtest-table th { background-color: #e9ecef; color: #333; }
    </style>
</head>
<body onload="fetchHistoryData()">

<div class="container">
    <div id="main-view">
        <h1>æé€Ÿèµ›è½¦å®æ—¶å¼€å¥–</h1>
        
        <div id="top-info-card">
            <div id="latest-issue-title">æœ€æ–°å¼€å¥–æœŸå·ï¼š<span id="latest-issue">--</span></div>
            <div id="latest-numbers-display">
                <p id="latest-loading-text">æ­£åœ¨åŠ è½½æœ€æ–°å¼€å¥–...</p>
            </div>
            <div id="countdown-section">
                <span id="next-issue">ä¸‹ä¸€æœŸï¼š--</span> å€’è®¡æ—¶ï¼š<span id="countdown-timer">--</span>
            </div>
        </div>
        
        <div id="status-message">æ­£åœ¨è¿æ¥ API è·å–æ•°æ®...</div>

        <button class="view-switch-button" onclick="showView('prediction-home-view')">é¢„æµ‹ç³»ç»Ÿ</button>

        <h2>å†å²å¼€å¥–è®°å½•</h2>
        <table id="data-table">
            <colgroup><col style="width: 20%;"><col style="width: 15%;"><col></colgroup>
            <thead>
                <tr>
                    <th>æœŸå·</th><th>æ—¶é—´</th><th>å¼€å¥–å·ç  (1~10ä½)</th>
                </tr>
            </thead>
            <tbody id="table-body"></tbody>
        </table>
    </div>

    <div id="prediction-home-view" style="display:none;">
        <button class="back-button" onclick="showView('main-view')">â† è¿”å›ä¸»é¡µ</button>
        
        <div id="smart-prediction-card">
            <div id="smart-selection-result">
                <div class="prediction-line" style="color: green; margin-bottom: 15px;">
                    ğŸ¯ **æœ€ä¼˜è¿å¯¹ï¼š** <span id="best-lane-display">--</span> 
                    <span style="float: right;">è¿ä¸­ <span id="best-consecutive-display">--</span> æœŸ</span>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <span id="best-predict-numbers">--</span>
                </div>

                <div class="prediction-line" style="color: red; margin-bottom: 15px; border-top: 1px dashed #ccc; padding-top: 10px;">
                    ğŸ“‰ **æœ€å¤§è¿é”™ï¼š** <span id="worst-lane-display">--</span> 
                    <span style="float: right;">è¿é”™ <span id="worst-consecutive-display">--</span> æœŸ</span>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <span id="worst-predict-numbers">--</span>
                </div>

                <div style="text-align: center; border-top: 1px dashed #ccc; padding-top: 10px; font-size: 1.1em; font-weight: bold; color: #333;">
                    âœ… **å¹³å‡å‘½ä¸­ç‡ (è¿‘20æœŸ)ï¼š** <span id="avg-hit-rate">--</span>
                </div>
            </div>
        </div>

        <h2 style="text-align:center; color:#333;">ä»…ä¾›å‚è€ƒä»·å€¼æœ‰é—®é¢˜è”ç³»tg:@lipu3888888</h2>
        <div id="lane-buttons-container">
        </div>
    </div>

    <div id="model-detail-view" style="display:none;">
        <button class="back-button" onclick="showView('prediction-home-view')">â† è¿”å›é¢„æµ‹ä¸»é¡µ</button>
        <div id="detail-header">
            <h2 id="detail-title" style="font-size: 1.4em;"></h2>
            
            <div id="detail-prediction-area" style="text-align:center; margin-top: 15px; border: 1px solid #007bff; padding: 10px; border-radius: 4px;">
                <div class="prediction-line">
                    ä¸‹ä¸€æœŸé¢„æµ‹åŒ…å›´å·ç ï¼š
                    <span id="detail-predict-numbers">--</span>
                </div>
            </div>
            <div style="text-align: center; margin-top: 10px; font-weight: bold;">
                è¿‘100æœŸå‘½ä¸­ç‡ï¼š<span id="detail-hit-rate">--</span>
            </div>
        </div>
        
        <h3 style="color:#333;">æ¨¡å‹å›æµ‹è®°å½• (è¿‘100æœŸ)</h3>
        <table id="backtest-table">
            <colgroup><col style="width: 20%;"><col style="width: 30%;"><col style="width: 15%;"><col style="width: 18%;"><col style="width: 17%;"></colgroup>
            <thead>
                <tr>
                    <th>æœŸå·</th>
                    <th>é¢„æµ‹åŒ…å›´</th>
                    <th>å®é™…å¼€å¥–</th>
                    <th>å‘½ä¸­</th>
                    <th>è¿å¯¹/é”™</th>
                </tr>
            </thead>
            <tbody id="backtest-table-body">
            </tbody>
        </table>
    </div>

</div>

<script>
    const API_URL = 'https://1689689.com/api/pks/getPksHistoryList.do?lotCode=10037'; 
    const MAX_HISTORY_LENGTH = 100; // V5.6 æ›´æ”¹ï¼šå›æµ‹è®°å½•é•¿åº¦å¢åŠ åˆ° 100
    const API_DATA_LIMIT = 50; // APIæœ€å¤šè¿”å›50æœŸï¼Œå®é™…å›æµ‹é•¿åº¦å—æ­¤é™åˆ¶ï¼Œä½†æ¨¡å‹å†…å­˜å‚¨100
    const MIN_HISTORY_FOR_PREDICTION = 21; // è‡³å°‘éœ€è¦ 20æœŸåšè®¡ç®—åŸºå‡† + 1æœŸå¼€å¥–ç»“æœ

    let timerInterval;
    let currentLatestIssue = 0; 
    let historyDataCache = []; 
    let predictionModels = []; 
    let smartSelection = {
        best: { lane: '--', ruleName: 'åˆå§‹åŒ–', prediction: [], consecutive: 0 },
        worst: { lane: '--', ruleName: 'åˆå§‹åŒ–', prediction: [], consecutive: 0 },
        avgHitRate: '0.00%',
    }; 

    // è§„å¾‹å®šä¹‰
    const RULES = {
        'G4': 'ç¥ç‹è½¬æ¢ (20æœŸç»Ÿè®¡)',
    };
    
    // åˆå§‹åŒ–æ¨¡å‹ç»“æ„
    function initializeModels() {
        predictionModels = [];
        for (let i = 1; i <= 10; i++) {
            const laneModel = { lane: i, rules: {} };
            laneModel.rules['G4'] = {
                ruleId: 'G4',
                ruleName: RULES['G4'],
                predictionHistory: [],    // è®°å½•æœ€å¤š 100 æœŸå›æµ‹å†å²
                nextPredictNumbers: [],   
                lastPredictNumbers: [],   
                consecutive: 0,           
                isWin: true,              
                lastPredictType: 'HOT',
                hitRate: '0.00%'
            };
            predictionModels.push(laneModel);
        }
        smartSelection.best = { lane: '--', ruleName: 'åˆå§‹åŒ–', prediction: [], consecutive: 0 };
        smartSelection.worst = { lane: '--', ruleName: 'åˆå§‹åŒ–', prediction: [], consecutive: 0 };
        smartSelection.avgHitRate = '0.00%';
    }
    
    // åˆ‡æ¢è§†å›¾å‡½æ•°
    function showView(viewId, lane = null, ruleId = null) {
        document.getElementById('main-view').style.display = 'none';
        document.getElementById('prediction-home-view').style.display = 'none';
        document.getElementById('model-detail-view').style.display = 'none';

        if (viewId === 'prediction-home-view') {
            updateSmartSelectionDisplay();
            generateLaneButtons();
        } else if (viewId === 'model-detail-view' && lane !== null && ruleId !== null) {
            renderModelDetail(lane, ruleId);
        }
        document.getElementById(viewId).style.display = 'block';
    }

    // ************************************
    // ** æ ¸å¿ƒè§„å¾‹é¢„æµ‹å‡½æ•°ï¼šå†·çƒ­ç è½¬æ¢ (G4) **
    // ************************************

    /**
     * ç»Ÿè®¡æŒ‡å®šè½¦é“åœ¨è¿‘20æœŸçš„å†·çƒ­å·ï¼Œå¹¶è¿”å› 8 ç çš„åŒ…å›´åœˆã€‚
     * é€»è¾‘ä¿æŒä¸å˜ã€‚
     */
    function getHotColdEnclosures(targetLane, historyRecords) {
        if (historyRecords.length < 20) return { hot: [], cold: [] }; 

        const laneIndex = targetLane - 1;
        const countMap = {};
        const allNumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        
        // ç»Ÿè®¡è¿™ 20 æœŸæ•°æ®çš„å‡ºç°æ¬¡æ•°
        for (let i = 0; i < 20; i++) {
            const result = historyRecords[i].preDrawCode.split(',').map(n => parseInt(n));
            const num = result[laneIndex];
            countMap[num] = (countMap[num] || 0) + 1;
        }

        const sortedNumbersByCount = allNumbers
            .map(num => ({ num, count: countMap[num] || 0 }))
            .sort((a, b) => {
                if (b.count !== a.count) {
                    return b.count - a.count; 
                }
                return a.num - b.num; 
            });
        
        const hotEight = sortedNumbersByCount.slice(0, 8).map(item => item.num).sort((a, b) => a - b);
        const coldEight = sortedNumbersByCount.slice(2, 10).map(item => item.num).sort((a, b) => a - b);
        
        return { hot: hotEight, cold: coldEight };
    }
    
    /**
     * è®¡ç®—æ¨¡å‹å‘½ä¸­ç‡ï¼ˆè¿‘ N æœŸï¼‰ã€‚
     * @param {Array<Object>} history - é¢„æµ‹å†å²è®°å½•ã€‚
     * @returns {string} å‘½ä¸­ç‡ç™¾åˆ†æ¯”å­—ç¬¦ä¸²ã€‚
     */
    function calculateHitRate(history) {
        if (history.length === 0) return '0.00%';
        const wins = history.filter(entry => entry.correct).length;
        const rate = (wins / history.length) * 100;
        return rate.toFixed(2) + '%';
    }


    /**
     * æ ¸å¿ƒé€»è¾‘ï¼šæ‰§è¡Œå•æœŸå›æµ‹å’Œé¢„æµ‹ã€‚
     */
    function runSinglePrediction(currentHistory, model, latestRecord) {
        const targetLane = model.lane; 
        const rule = model.rules['G4']; 
        
        const { hot: hotEnclosure, cold: coldEnclosure } = getHotColdEnclosures(targetLane, currentHistory);
        
        // 2. å›æµ‹ä¸Šä¸€æœŸ (latestRecord)
        const lastPredictNumbers = rule.lastPredictNumbers;
        const lastPredictType = rule.lastPredictType;
        const latestResult = latestRecord.preDrawCode.split(',').map(n => parseInt(n));

        if (lastPredictNumbers.length > 0) {
            const actualNumber = latestResult[targetLane - 1];
            const isCorrect = lastPredictNumbers.includes(actualNumber);
            
            // æ›´æ–°è¿å¯¹/è¿é”™è®¡æ•°
            if (isCorrect) {
                rule.consecutive = rule.isWin ? rule.consecutive + 1 : 1;
                rule.isWin = true;
                rule.nextPredictType = lastPredictType;
            } else {
                rule.consecutive = rule.isWin ? 1 : rule.consecutive + 1;
                rule.isWin = false;
                rule.nextPredictType = (lastPredictType === 'HOT') ? 'COLD' : 'HOT';
            }
            
            // è®°å½•å›æµ‹å†å² (V5.6: é•¿åº¦é™åˆ¶ MAX_HISTORY_LENGTH)
            const historyEntry = {
                issue: latestRecord.preDrawIssue,
                predictedNumbers: lastPredictNumbers.join(','), 
                actual: actualNumber,
                correct: isCorrect,
                consecutive: rule.consecutive,
                isWin: rule.isWin,
                predictType: lastPredictType
            };
            rule.predictionHistory.unshift(historyEntry); 
            if (rule.predictionHistory.length > MAX_HISTORY_LENGTH) rule.predictionHistory.pop();
            
            // è®¡ç®—å¹¶æ›´æ–°å‘½ä¸­ç‡ (åŸºäºå½“å‰æ‰€æœ‰çš„å›æµ‹è®°å½•)
            rule.hitRate = calculateHitRate(rule.predictionHistory);
        } else {
            rule.nextPredictType = 'HOT'; 
            rule.hitRate = '0.00%';
        }

        // 3. é¢„æµ‹ä¸‹ä¸€æœŸ 
        const nextType = rule.nextPredictType;
        let newPrediction;
        if (nextType === 'HOT') {
            newPrediction = hotEnclosure;
        } else {
            newPrediction = coldEnclosure;
        }
        
        rule.nextPredictNumbers = newPrediction;
        rule.lastPredictNumbers = newPrediction; 
        rule.lastPredictType = nextType; 

        return { 
            isWin: rule.isWin, 
            consecutive: rule.consecutive, 
            nextPredictNumbers: newPrediction,
            hitRate: rule.hitRate 
        };
    }
    
    /**
     * åˆå§‹åŠ è½½æ—¶ï¼Œåˆ©ç”¨å†å²æ•°æ®ï¼Œä»æœ€æ—§åˆ°æœ€æ–°ï¼Œæ¨¡æ‹Ÿå›æµ‹ï¼Œç”Ÿæˆåˆå§‹é¢„æµ‹è®°å½•ã€‚
     */
    function recalculateInitialPrediction(historyRecords) {
        const N = historyRecords.length;
        if (N < MIN_HISTORY_FOR_PREDICTION) {
            initializeModels(); 
            return;
        }

        initializeModels(); 
        
        // å¾ªç¯èµ·ç‚¹ï¼ši = N - 20ã€‚ 
        // ç¡®ä¿ç”¨äºè®¡ç®—å†·çƒ­çš„ currentHistory å§‹ç»ˆæœ‰ 20 æœŸæ•°æ®ã€‚
        // å¦‚æœ N=35ï¼Œi ä» 15 å¼€å§‹ï¼Œåˆ° 1 ç»“æŸã€‚å…± 15 æ¬¡å›æµ‹ã€‚
        // å¦‚æœ N=50ï¼Œi ä» 30 å¼€å§‹ï¼Œåˆ° 1 ç»“æŸã€‚å…± 30 æ¬¡å›æµ‹ã€‚
        const startIdx = N - 20;
        
        // è¿½è¸ªæœ€ä¼˜å’Œæœ€å·®
        let maxWinConsecutive = -1;
        let maxLossConsecutive = -1;
        let bestSelection = { lane: '--', ruleName: 'æ— ç¨³å®šè§„å¾‹', prediction: [], consecutive: 0 };
        let worstSelection = { lane: '--', ruleName: 'æ— ç¨³å®šè§„å¾‹', prediction: [], consecutive: 0 };
        
        const totalRuns = N - 20;
        let totalHitCount = 0;

        for (let i = startIdx; i > 0; i--) {
            // currentHistory: ç”¨äºè®¡ç®—å†·çƒ­çš„ 20 æœŸæ•°æ® (API è®°å½•çš„ç´¢å¼• i åˆ° i+19)
            const currentHistory = historyRecords.slice(i, i + 20); 
            
            // latestRecord: å®é™…å¼€å¥–çš„é‚£ä¸€æœŸ (API è®°å½•çš„ç´¢å¼• i-1)
            const latestRecord = historyRecords[i - 1]; 
            
            predictionModels.forEach(model => {
                const results = runSinglePrediction(currentHistory, model, latestRecord);

                // ä»…åœ¨æœ€åä¸€æ¬¡å¾ªç¯ (i=1ï¼Œå³æœ€æ–°ä¸€æœŸå›æµ‹å®Œæ¯•å) æ›´æ–°å…¨å±€æ™ºèƒ½é€‰æ‹©
                if (i === 1) {
                    const rule = model.rules['G4'];
                    
                    // è¿½è¸ªæœ€ä¼˜è¿å¯¹
                    if (rule.isWin && rule.consecutive > maxWinConsecutive) {
                        maxWinConsecutive = rule.consecutive;
                        bestSelection = {
                            lane: model.lane,
                            ruleName: rule.ruleName,
                            prediction: rule.nextPredictNumbers,
                            consecutive: maxWinConsecutive
                        };
                    }
                    // è¿½è¸ªæœ€å¤§è¿é”™
                    if (!rule.isWin && rule.consecutive > maxLossConsecutive) {
                        maxLossConsecutive = rule.consecutive;
                        worstSelection = {
                            lane: model.lane,
                            ruleName: rule.ruleName,
                            prediction: rule.nextPredictNumbers,
                            consecutive: maxLossConsecutive
                        };
                    }
                }
            });
        }
        
        // 4. è®¡ç®—æ‰€æœ‰æ¨¡å‹åœ¨è¿‘20æœŸçš„å¹³å‡å‘½ä¸­ç‡ (ä½¿ç”¨æœ€æ–°ç”Ÿæˆçš„è®°å½•)
        let totalWinCountLast20 = 0;
        let totalCheckCountLast20 = 0;

        predictionModels.forEach(model => {
            const history = model.rules['G4'].predictionHistory.slice(0, 20); // åªçœ‹è¿‘ 20 æœŸ
            totalCheckCountLast20 += history.length;
            totalWinCountLast20 += history.filter(entry => entry.correct).length;
        });

        // 5. æ›´æ–°å…¨å±€æ™ºèƒ½ç­›é€‰ç»“æœ
        smartSelection.best = bestSelection;
        smartSelection.worst = worstSelection;
        if (totalCheckCountLast20 > 0) {
            const avgRate = (totalWinCountLast20 / totalCheckCountLast20) * 100;
            smartSelection.avgHitRate = avgRate.toFixed(2) + '%';
        } else {
             smartSelection.avgHitRate = '0.00%';
        }
        
        console.log(`ğŸ‰ åˆå§‹å›æµ‹å®Œæˆï¼å·²ç”Ÿæˆ ${totalRuns} æœŸé¢„æµ‹è®°å½•ã€‚`);
    }


    /**
     * å¢é‡æ›´æ–°ï¼šåªå¤„ç† API è¿”å›çš„æœ€æ–°ä¸€æœŸæ•°æ®ã€‚
     */
    function monitorHistoryAndPredict(historyRecords) {
        if (!historyRecords || historyRecords.length < MIN_HISTORY_FOR_PREDICTION) return;
        
        const latestRecord = historyRecords[0];
        const latestIssue = parseInt(latestRecord.preDrawIssue);

        if (latestIssue === currentLatestIssue) return;
        currentLatestIssue = latestIssue;

        let maxWinConsecutive = -1;
        let maxLossConsecutive = -1;
        let bestSelection = { lane: '--', ruleName: 'æ— ç¨³å®šè§„å¾‹', prediction: [], consecutive: 0 };
        let worstSelection = { lane: '--', ruleName: 'æ— ç¨³å®šè§„å¾‹', prediction: [], consecutive: 0 };
        
        let totalWinCountLast20 = 0;
        let totalCheckCountLast20 = 0;


        predictionModels.forEach(model => {
            // ç”¨äºè®¡ç®—å†·çƒ­çš„ 20 æœŸæ•°æ®æ˜¯ historyRecords çš„ [1] åˆ° [20]
            const currentHistory = historyRecords.slice(1, 21); 
            const results = runSinglePrediction(currentHistory, model, latestRecord);
            
            // è¿½è¸ªæœ€ä¼˜è¿å¯¹
            if (results.isWin && results.consecutive > maxWinConsecutive) {
                maxWinConsecutive = results.consecutive;
                bestSelection = {
                    lane: model.lane,
                    ruleName: model.rules['G4'].ruleName,
                    prediction: results.nextPredictNumbers,
                    consecutive: maxWinConsecutive
                };
            }
             // è¿½è¸ªæœ€å¤§è¿é”™
            if (!results.isWin && results.consecutive > maxLossConsecutive) {
                maxLossConsecutive = results.consecutive;
                worstSelection = {
                    lane: model.lane,
                    ruleName: model.rules['G4'].ruleName,
                    prediction: results.nextPredictNumbers,
                    consecutive: maxLossConsecutive
                };
            }
            
            // ç»Ÿè®¡å‘½ä¸­ç‡æ•°æ®
            const history = model.rules['G4'].predictionHistory.slice(0, 20);
            totalCheckCountLast20 += history.length;
            totalWinCountLast20 += history.filter(entry => entry.correct).length;
        });
        
        // æ›´æ–°å…¨å±€æ™ºèƒ½ç­›é€‰ç»“æœ
        smartSelection.best = bestSelection;
        smartSelection.worst = worstSelection;
        if (totalCheckCountLast20 > 0) {
            const avgRate = (totalWinCountLast20 / totalCheckCountLast20) * 100;
            smartSelection.avgHitRate = avgRate.toFixed(2) + '%';
        } else {
             smartSelection.avgHitRate = '0.00%';
        }
    }


    // ************************************
    // ** API & Timer Logic (ä¿æŒä¸å˜) **
    // ************************************

    function startCountdown(preDrawTimeStr, preDrawIssue) {
        if (timerInterval) clearInterval(timerInterval);
        const preDrawTime = new Date(preDrawTimeStr.replace(/-/g, "/"));
        const nextDrawTime = new Date(preDrawTime.getTime() + 60000); 
        const nextIssue = parseInt(preDrawIssue) + 1;
        document.getElementById('next-issue').textContent = `ä¸‹ä¸€æœŸï¼š${nextIssue}`;
        const timerElement = document.getElementById('countdown-timer');

        function updateTimer() {
            const now = new Date();
            let difference = nextDrawTime - now;
            if (difference <= 0) {
                if (timerInterval) clearInterval(timerInterval); 
                timerElement.textContent = 'ç­‰å¾…å¼€å¥–...';
                document.getElementById('status-message').textContent = 'ğŸ”„ æ­£åœ¨æ£€æŸ¥æœ€æ–°å¼€å¥–ç»“æœ...';
                timerInterval = setInterval(checkForNewData, 1000, nextIssue);
                return;
            }
            const totalSeconds = Math.floor(difference / 1000);
            const seconds = String(totalSeconds).padStart(2, '0');
            timerElement.textContent = `00:${seconds}`;
        }
        updateTimer();
        timerInterval = setInterval(updateTimer, 1000);
    }

    async function checkForNewData(expectedNewIssue) {
        try {
            const response = await fetch(API_URL);
            const data = await response.json();
            const newData = data.result.data;
            if (!newData || newData.length === 0) return;

            const newLatestIssue = parseInt(newData[0].preDrawIssue);
            const latestRecord = newData[0];

            if (newLatestIssue > currentLatestIssue) {
                document.getElementById('status-message').textContent = 'ğŸ‰ å·²æ›´æ–°åˆ°æœ€æ–°å¼€å¥–ï¼æ­£åœ¨åˆ†æè§„å¾‹...';
                if (timerInterval) clearInterval(timerInterval); 
                
                historyDataCache.unshift(latestRecord);
                if (historyDataCache.length > API_DATA_LIMIT) historyDataCache.pop(); // ä¿æŒAPIæ•°æ®é™åˆ¶
                
                monitorHistoryAndPredict(historyDataCache); 
                
                renderLatestResultCard(latestRecord);
                insertNewHistoryRow(latestRecord); 
                
                startCountdown(latestRecord.preDrawTime, latestRecord.preDrawIssue);
                
                if (document.getElementById('prediction-home-view').style.display === 'block') {
                    updateSmartSelectionDisplay();
                    generateLaneButtons();
                }

            } else {
                document.getElementById('status-message').textContent = `ğŸ”„ æ­£åœ¨ç­‰å¾… ${expectedNewIssue} æœŸå¼€å¥–ç»“æœ...`;
            }
        } catch (error) {
            document.getElementById('status-message').textContent = 'âš ï¸ æ£€æŸ¥æ•°æ®å¤±è´¥ï¼Œæ­£åœ¨é‡è¯•...';
        }
    }


    async function fetchHistoryData() {
        const statusMessage = document.getElementById('status-message');
        const tableBody = document.getElementById('table-body');
        
        statusMessage.textContent = 'æ­£åœ¨è¿æ¥ API è·å–æ•°æ®...';
        tableBody.innerHTML = '';

        try {
            const response = await fetch(API_URL);
            if (!response.ok) throw new Error(`HTTP é”™è¯¯ï¼çŠ¶æ€ç : ${response.status}`);
            const data = await response.json();
            
            historyDataCache = data.result.data;

            if (!historyDataCache || historyDataCache.length === 0) {
                statusMessage.textContent = 'âœ… æ•°æ®è·å–æˆåŠŸï¼Œä½†å†å²è®°å½•ä¸ºç©ºã€‚';
                return;
            }
            
            // 1. æ¸²æŸ“å†å²è¡¨æ ¼
            historyDataCache.forEach((record) => {
                const issue = record.preDrawIssue;
                const openTime = record.preDrawTime.split(' ')[1].substring(0, 5); 
                const numbers = record.preDrawCode.split(',').map(num => parseInt(num));
                if (numbers.length !== 10) return;
                let row = tableBody.insertRow(); 
                row.insertCell().textContent = issue;
                row.insertCell().textContent = openTime;
                const ballsContainerCell = row.insertCell();
                let ballsHTML = '<div class="balls-container">';
                numbers.forEach((num) => { ballsHTML += renderBlockHTML(num, false); });
                ballsHTML += '</div>';
                ballsContainerCell.innerHTML = ballsHTML;
            });

            // 2. æ ¸å¿ƒï¼šåˆ©ç”¨å†å²æ•°æ®ï¼Œä»æœ€æ—§åˆ°æœ€æ–°ï¼Œæ¨¡æ‹Ÿå›æµ‹ï¼Œç”Ÿæˆåˆå§‹é¢„æµ‹è®°å½•
            if (historyDataCache.length >= MIN_HISTORY_FOR_PREDICTION) { 
                recalculateInitialPrediction(historyDataCache);
            } else {
                initializeModels();
                statusMessage.textContent += ` (APIæ•°æ®ä¸è¶³${MIN_HISTORY_FOR_PREDICTION}æœŸï¼Œæš‚æ— å›æµ‹è®°å½•)`;
            }
            
            // 3. è®¾ç½®æœ€æ–°æœŸå·ï¼Œæ¸²æŸ“é¡¶éƒ¨å¡ç‰‡ï¼Œå¹¶å¯åŠ¨å€’è®¡æ—¶
            const latestRecord = historyDataCache[0];
            currentLatestIssue = parseInt(latestRecord.preDrawIssue); 
            renderLatestResultCard(latestRecord);
            startCountdown(latestRecord.preDrawTime, latestRecord.preDrawIssue);
            

            statusMessage.textContent = `âœ… åŠ è½½æˆåŠŸï¼æ™ºèƒ½åˆ†æå·²å°±ç»ªã€‚`;
            statusMessage.style.backgroundColor = '#d4edda';
            statusMessage.style.color = '#155724';

        } catch (error) {
            console.error('API æ•°æ®è·å–å¤±è´¥:', error);
            statusMessage.textContent = `âŒ æ•°æ®è·å–å¤±è´¥: ${error.message} (è¯·æ£€æŸ¥ç½‘ç»œ)`;
            statusMessage.style.backgroundColor = '#f2dede';
            statusMessage.style.color = '#a94442';
            if (timerInterval) {
                clearInterval(timerInterval);
                document.getElementById('countdown-timer').textContent = 'åŠ è½½å¤±è´¥';
            }
        }
    }
    
    // ************************************
    // ** æ¸²æŸ“å‡½æ•° (V5.6 ä¿®æ”¹) **
    // ************************************
    function renderPredictBalls(predictNumbers) {
        if (!predictNumbers || predictNumbers.length === 0) return '<span style="color:#999;">æš‚æ— åŒ…å›´åœˆ</span>';
        return predictNumbers.map(num => 
            `<span class="predict-ball color-${num}">${num.toString().padStart(2, '0')}</span>`
        ).join('');
    }

    function updateSmartSelectionDisplay() {
        const best = smartSelection.best;
        const worst = smartSelection.worst;

        // æ¸²æŸ“æœ€ä¼˜è¿å¯¹
        document.getElementById('best-lane-display').textContent = best.lane !== '--' ? `é¢„æµ‹ç¬¬ ${best.lane} å` : 'æ— ç¨³å®šè¿å¯¹è§„å¾‹';
        document.getElementById('best-consecutive-display').textContent = best.consecutive > 0 ? `${best.consecutive}` : '--';
        document.getElementById('best-predict-numbers').innerHTML = renderPredictBalls(best.prediction);

        // æ¸²æŸ“æœ€å¤§è¿é”™
        document.getElementById('worst-lane-display').textContent = worst.lane !== '--' ? `é¢„æµ‹ç¬¬ ${worst.lane} å` : 'æ— æœ€å¤§è¿é”™è§„å¾‹';
        document.getElementById('worst-consecutive-display').textContent = worst.consecutive > 0 ? `${worst.consecutive}` : '--';
        document.getElementById('worst-predict-numbers').innerHTML = renderPredictBalls(worst.prediction);
        
        // æ¸²æŸ“å¹³å‡å‘½ä¸­ç‡
        document.getElementById('avg-hit-rate').textContent = smartSelection.avgHitRate;
    }

    function generateLaneButtons() {
        const container = document.getElementById('lane-buttons-container');
        let html = '';
        
        predictionModels.forEach(model => {
            const rule = model.rules['G4'];
            const statusText = rule.isWin ? `è¿å¯¹ ${rule.consecutive}` : `è¿é”™ ${rule.consecutive}`;
            const statusClass = rule.isWin ? 'result-win' : 'result-loss';
            const predictDisplay = rule.nextPredictNumbers.length > 0 ? rule.nextPredictNumbers.length + ' ç åŒ…å›´' : 'å¾…é¢„æµ‹';

            html += `
                <div class="lane-button" onclick="showView('model-detail-view', ${model.lane}, 'G4')">
                    <div>
                        **ç¬¬ ${model.lane} å** - ${rule.ruleName}
                    </div>
                    <div style="font-size: 0.9em; margin-top: 5px;">
                        <span class="${statusClass}">${statusText}</span> | é¢„æµ‹: ${predictDisplay} (${rule.lastPredictType})
                        <span style="float: right;">å‘½ä¸­ç‡: ${rule.hitRate}</span>
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;
    }

    function renderModelDetail(lane, ruleId) {
        const model = predictionModels.find(m => m.lane === lane);
        if (!model || !model.rules[ruleId]) return;
        const rule = model.rules[ruleId];

        document.getElementById('detail-title').textContent = `ç¬¬ ${lane} å - ${rule.ruleName} è§„å¾‹è¯¦æƒ… (ä¸‹ä¸€æœŸé¢„æµ‹: ${rule.lastPredictType})`;
        document.getElementById('detail-predict-numbers').innerHTML = renderPredictBalls(rule.nextPredictNumbers);
        document.getElementById('detail-hit-rate').textContent = rule.hitRate; // V5.6 æ–°å¢å‘½ä¸­ç‡

        const tableBody = document.getElementById('backtest-table-body');
        tableBody.innerHTML = '';

        rule.predictionHistory.forEach(entry => {
            const resultClass = entry.correct ? 'result-win' : 'result-loss';
            const resultText = entry.correct ? 'âœ… å‘½ä¸­' : 'âŒ è½ç©º';
            const statusText = entry.isWin ? `è¿å¯¹ ${entry.consecutive}` : `è¿é”™ ${entry.consecutive}`;
            const predictType = entry.predictType === 'HOT' ? 'ç™½ç ' : 'é»‘ç ';

            const row = tableBody.insertRow();
            row.insertCell().textContent = entry.issue;
            row.insertCell().textContent = entry.predictedNumbers; 
            row.insertCell().textContent = entry.actual;
            row.insertCell().innerHTML = `<span class="${resultClass}">${resultText}</span>`;
            row.insertCell().textContent = `${statusText} (${predictType})`;
        });
    }

    function renderBlockHTML(num, isTopCard) {
        const numStr = num.toString().padStart(2, '0');
        const colorClass = `color-${num}`;
        const sizeClass = isTopCard ? 'top-ball' : 'ball'; 
        return `<span class="${sizeClass} ${colorClass}">${numStr}</span>`;
    }

    function renderLatestResultCard(record) {
        const numbers = record.preDrawCode.split(',').map(num => parseInt(num));
        const latestDisplay = document.getElementById('latest-numbers-display');
        const latestIssueElement = document.getElementById('latest-issue');
        latestIssueElement.textContent = record.preDrawIssue;
        let ballsHTML = '<div class="balls-container">';
        numbers.forEach((num) => { ballsHTML += renderBlockHTML(num, true); });
        ballsHTML += '</div>';
        latestDisplay.innerHTML = ballsHTML;
        const loadingText = document.getElementById('latest-loading-text');
        if (loadingText) loadingText.style.display = 'none';
    }
    
    function insertNewHistoryRow(record) {
        const tableBody = document.getElementById('table-body');
        const issue = record.preDrawIssue;
        const openTime = record.preDrawTime.split(' ')[1].substring(0, 5); 
        const numbers = record.preDrawCode.split(',').map(num => parseInt(num));
        if (numbers.length !== 10) return;

        let row = tableBody.insertRow(0); 
        
        row.insertCell().textContent = issue;
        row.insertCell().textContent = openTime;

        const ballsContainerCell = row.insertCell();
        let ballsHTML = '<div class="balls-container">';
        numbers.forEach((num) => { ballsHTML += renderBlockHTML(num, false); });
        ballsHTML += '</div>';
        ballsContainerCell.innerHTML = ballsHTML;
        
        if (tableBody.rows.length > API_DATA_LIMIT) { 
            tableBody.deleteRow(API_DATA_LIMIT); 
        }
    }
</script>

</body>
</html>